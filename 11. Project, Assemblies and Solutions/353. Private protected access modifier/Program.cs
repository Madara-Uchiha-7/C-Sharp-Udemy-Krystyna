///
/// Additionally, we will learn the purpose of the file access modifier.
/// 
/// Let's start with private protected. Within the same assembly
/// it works as protected.
/// 
/// So types and members with this access modifier will be accessible in derived types only. Outside this
/// it works as private, so it is not accessible at all.
/// 
/// As you can see, 
/// we have added
/// private protected void PrivateProtected() { }
/// in the 
/// PublicClass
/// in the "349_1. Utilities"
/// 
/// And we are using this method in
/// UsingPublicClass class
/// because this class derives the PublicClass.
/// We have defined the UsingPublicClass class public, we can also define it as the internal.
/// 
/// We will not be able to call this method in another assembly, even in a class derived from PublicClass.
/// For e.g. if we create a class here in this project,
/// and even though we have added "349_1. Utilities" as the project reference.
/// and 
/// then even if our class derives the PublicClass,
/// we will not be able to call that method in this class.
/// 
/// 
/// There is one more access modifier : the file access modifier.
/// 
/// It can only be applied to types, not to members.
/// E.g.
/// We have added class
/// AccessibleOnlyInThisFile
/// in the "349_1. Utilities".
/// This class will be accessible in "349_1. Utilities" file, but not in any other files, no matter the assembly.
/// This modifier is available starting with C# 11.
/// 
/// Developers rarely use it, and its main purpose is to be used with auto-generated code.
/// So code that has not been written by hand but generated by some other program.
/// Such programs often need to define many types with the same names, meant to be used only in the files
/// they belong to.
/// Thanks to the file access modifier, those names don't collide with each other so we don't get compilation
/// errors because there are many types named the same.
/// Each of those types is only visible in the file it is defined in.
/// 
/// 
///