// Having each class in seperate file is generally a good practice.
// We should always have one file for one class in production code.
// We can move a class to its own file in two ways
///
/// 1. To do it manually. 
/// Creating a sepearte file for class.
/// Right click on project -> Add New Item -> Select class and type the name of the class.
/// When you do so, you will see some "Using" statements used for imports.
/// If some imports are graded then it means that we do not need them or we have not used them in our code.
/// After this you will have a namespace and class name which will same as the file name.
/// For now ignore this namespace and auto generated class.
/// Now save all the files using ctl + shift + s
/// The main file i.e. the program.cs which has your other code which uses this copied class will still compile.
/// While coping and pasting the class manually, if you remove the namespace and paste the code
/// at the place of the auto generated class, then to the other main file you will get an error while compilation.
/// We create the namespaces to declare the scope that contains a set of related types(classes).
/// You can rename the namespace which is autogenerated.
/// It is a good practice to have the namespaces.
/// Namespaces names should match the folder structure.
/// Right click on the project -> add -> new folder -> Give the valid and good name to that folder.
/// Use that same folder name to the namespace.
/// We can have more that one namespace in the same class file.
/// We can also have the nested namespaces.
/// If you right click/ hover over the namespace and check on suggessions from the VS then you will see
/// that VS suggests a name for our namespace. It uses this format for naming : ProjectName.NameOfFolder
/// Types which are not declared in any namespace belogs to the global namespace.
/// 2. Right click to class name -> Quick actions and Refactoring -> Move Type to classNameValidator.cs
/// ***************************
/// There are tabs which open on the VS in which you add a code.
/// You can pin those tabs and the pined tab will be kept on the left most side.
/// **************************
/// If you remove the braces of the namespaces and add the ; after the namespace then you can 
/// clear the unecessary indentation. This is called as the File Scoped Namespace declaration (C# 10 or newer)
/// *************************
/// Now, when you use namespaces in other classes which are used in your file which you are going to compile,
/// you need to tell this file which you are going to compile that these are the X, Y, Z namespaces I have 
/// used and the classes which you want to use are in these namespaces.
/// This can be done using the "using" directives.
/// On the top of the code add 
/// using name_of_namespace; // This name is the name which you have given in class file which will be in the folder.
/// Then all the types defined in this namespace will be available in the file which you will compile.
/// If we import the main namespace then all the subnamespaces will be imported too. 
/// But you can also get specific namespace,
/// You have to show with the help of using directives and concatinate the namespaces using the. 
/// For e.g. using mainNameSpace.Folder.SubNameSpaceA;
/// 


// We will implement above data for the code which we have used in the 89.SRP


using _90._Files__namespaces_and_the_using_directive.FileReaderWriter;

Names names = new Names();
string path = new NamesFilePathBuilder().BuildFilePath();
StringsTextualRepository stringsTextualRepository = new StringsTextualRepository();
if (File.Exists(path))
{
    Console.WriteLine("Name file already exists. Loading names.");
    List<string> stringsFromFile = stringsTextualRepository.Read(path);
    names.AddNames(stringsFromFile);
}
else
{
    Console.WriteLine("Names file does not yet exists");

    names.AddName("John");
    names.AddName("not a valid name");
    names.AddName("Claire");
    names.AddName("123 definitely not a valid name");

    Console.WriteLine("Saving user defined names in the file.");
    stringsTextualRepository.Write(path, names.All);
}
Console.WriteLine(new NameFormatter().Format(names.All));
Console.ReadKey();

class Names
{
    public List<string> All { get; } = new List<string>();
    private readonly NamesValidator _namesValidator = new NamesValidator();

    public void AddNames(List<string> stringsFromFile)
    {
        foreach (string name in stringsFromFile)
        {
            AddName(name);
        }
    }
    public void AddName(string name)
    {
        if (_namesValidator.IsValid(name))
        {
            All.Add(name);
        }
    }
}