///
/// We will understand the purpose of the null forgiving operator.
/// We will also take a closer look at the warnings generated by Visual Studio.
/// 
/// There are use cases where we know better than the compiler if something can or cannot be null.
/// 
/// Consider class OddClass.
/// It has string Text and bool _isInitialized properties.
/// It does not have the constructor.
/// Instead it has a init method that does what the constructor should be doing.
/// It sets a member property.
/// It also sets the _isInitialized property flag to true.
/// 
/// The DoWork method, implements the main functionality of this class.
/// 
/// It will throw an exception if it was called without the init method being called first.
/// It checks 
/// if (!_isInitialized) throw new ....
/// 
/// It is a fishy design.
/// 
/// 
/// Classes should be ready to work right after being created and forcing the user to remember to call some
/// special Init method is suspicious.
/// 
/// Unfortunately, such code is not uncommon.
/// 
/// Let's say that for some reason we cannot refactor this class now and our current task is to get rid
/// of the warnings related to nullability of types.
/// 
/// While building the the project, compiler will show one warning in this code.
/// 
/// We declared Text property as non-nullable, but it is not set any value in the constructor because there
/// is no constructor.
/// 
/// So when this class is created, this property will be null, which isn't right. Since the compiler has
/// point here, we can decide to make this property a nullable string by adding ?.
/// i.e.
/// public string? Text { get; private set; }
/// 
/// Now the warning will go, but a new one will come.
/// Because in DoWork() we are doing Console.WriteLine(Text.Lenght);
/// 
/// Well, that's typical.
/// Making the code compliant with the compiler's requirements about the nullable reference types is a bit
/// like playing whack a mole.
/// One warning appears, but another pops up.
/// 
/// Again, this warning kind of makes sense.
/// The text property is nullable and here we try to access its length.
/// So there is a risk that null reference exception will be thrown.
/// 
/// But we as developers know that the text property is only used in the DoWork method and that Text.Lenght can
/// only be executed if the Init method was called first.
/// And Init method assigns a non-nullable string to the text property.
/// 
/// So, in this case, we know better than the compiler.
/// 
/// We wish we could tell it
/// "Give me a break here. I know what I'm doing."
/// 
/// And exactly for situations like this, the null-forgiving operator was introduced.
/// 
/// So, to remove the warning from Text.Lenght, we can do 
/// Text!.Length
/// 
/// 
/// As you can see, I simply put the exclamation mark after a nullable reference type object, which I
/// know is not null, just to suppress the warning.
/// 
/// Lets see another example.
/// After submitting this code to code review, we are given a comment.
/// The reviewer would like us to add a null check to the Init method to verify that the text parameter
/// is not null.
/// It is declared as non-nullable, so it shouldn't be.
/// Still, calling the init method with a null parameter will only generate a warning, so if someone ignores
/// it we will be in trouble.
/// 
/// Usually it's the constructor that validates if the non-nullable parameters are indeed not null.
/// But in this odd class, the Init method takes the role of the constructor.
/// So we decide to add a null check right here.
/// I.e. inside the Init method we will add
/// if (text is null) throw new ArgumentNullException(nameof(text));
/// 
/// The next step is to add an automated test that will check if this method does what it's meant to do.
/// It throws an exception if it is passed a null argument.
/*
void OddClassInit_ShallThrowExceptionWhenGivenNull()
{
    new OddClass().Init(null);
}
*/
/// The test should call the init method with the null argument and validate that it throws an exception.
/// Init(null) will cause warning.
/// 
/// We call the Init method with a null argument, but this method expects a non-nullable string.
/// But again, we know what we are doing.
/// We do it on purpose, for the sake of testing.
/// So again we can use the null-forgiving operator.
/// And make it:
/// .Init(null!);
/// 
/// 
/// Please be aware that this operator should not be overused.
/// The nullable reference types feature gives us reasonable warnings and if we suppress them all with the
/// null forgiving operator, it will be like this feature did not even exist.
/// 
/// There may be reasons for not using this feature.
/// Perhaps someone works on an old project and there is no agreement on the team level to fix all those
/// warnings.
/// But in this case this feature can be disabled in the project settings.
/// We can right-click on the project, select Properties,
/// Scroll down on the right side.
/// And here, in the Build options, we can choose to disable "Nullable" feature.
/// 
/// 
/// 
/// 
/// 
///