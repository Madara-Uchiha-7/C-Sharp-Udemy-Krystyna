using System.Reflection;
/// Above will be for reflection.


// 1:-
/// Reflection is the mechanism that allows us to write code that can inspect
/// types used in the application.
/// Using refelction we can list all the fields and their values belonging to 
/// given object, even if at compile time we don't know what is object type is
/// exactly. 
/// Lets say we want to write a class(ObjectToTextConvertor) that can take any 
/// objects and save them in the text file. Of course there are mechanisms that 
/// do it and store objects as JSON or XML.
/// 
///
ObjectToTextConvertor objectToTextConvertor = new ObjectToTextConvertor();
Console.WriteLine(
    objectToTextConvertor.Convert(
        new House("123 Maple Road", 170.6, 2)
        )
    );
Console.ReadKey();
class ObjectToTextConvertor
{
    public string Convert(object obj)
    {
        // 3:-
        /// If in the debug mode you check this type varibale in quick watch
        /// then check BaseType, DeclaredConstructor, DeclaredMethods, DeclaredProperties.
        /// In the DeclaredProperties we can see all the properties we have declared 
        /// with one extra property : EqualityContract which is autogenerated for the 
        /// records(records: I think teacher talking about records keyword here).
        /// We will ignore it when converting the object to string.
        Type type = obj.GetType();

        // 4:-
        /// Lets read all the properties except EqualityContract.
        IEnumerable<PropertyInfo> properties = type.GetProperties().Where(
            property => !property.Name.Equals("EqualityContract"));

        //5:- 
        /// Lets build a string for each property info:
        /// Accessing the property name as well as its value.
        /// Then we will join the strings together using LINQ.
        /// Select method from LINQ simply maps every property to the string.
        /// Then we joined those string using the Join method.
        return String.Join(
            ", ", 
            properties.Select(
                property => $"{property.Name} {property.GetValue(obj)}"
                )
            );
        
    }
}

// 2:-
/// record : we will learn about them later in the course.
/// For now assume they are the classes Pet and House with properties mentioned in the
/// parameters.
/// When pet and House objects are converted we want a result something like :
/// Name is Taiga, PetType is Dog, Weight is 30.0
/// For house Address is 123 Maple Road, Area is 170.6, Floors is 2
/// Problem is we have no idea what Type we need to deal in the convert method. <summary>
/// We can't cast the parameter to anything concrete as the type may vary. 
/// Also to implement what we want, we will not only need the values of the properties
/// which we could access if we only had more concrete type than System.Object,
/// but we also need their names, which are not available at run time.
/// In oter words, when using the House Floors property, we can get the number 2 
/// but we can not get the "Floors" string and we need it to build the string result
/// like mentioned above "Address is 123 Maple Road, Area is 170.6, Floors is 2".
/// Here in above example we can get 2 but we also need the Floors keyword.
/// To get this name of the property we can only use the reflection.
/// Relection allows us to access information about some type at runtime.
/// We can not only access the values of some fields, but also their names. 
/// Moreover we can access information about constructors, methods, access modifiers
/// and so on. We will use GetType method on the "obj" parameter.
/// It will return a Type object which provides our information about the type.

public record Pet(string name, PetType PetType, float Weight);
public record House(string Address, double Area, int Floors);
public enum PetType { Cat, Dog, Fish}


/// More points: 
/// How reflection helps us in more cases:
/// 1. Reflection allows us to load *.dlls at the runtime and using types defined in them.
/// 2. Instantiating a new instance of some object of a specific type at runtime.
/// For e.g. we can create an object of a type defined in a DLL that we loaded.
/// 3. Finding all classes derived from a specific type or implementing a specific 
/// interface.
/// 4. Reading the attributes.
/// 5. Later in the course we will learn how to write the unit tests using the NUnit.
/// Each unit test is just a method and to express it is a test method, we add a special
/// Test attribute to it. This way when all tests are run, NUnit can distinguish the 
/// test methods from regular methods. We will learn about attributes very soon. 
/// 6. Running a method by its name. For e.g. if the user of the application selected 
/// it from some dropdown.
/// 7. Debugging: For e.g. sometimes it is necessary to find out the list of all
/// currently loaded assemblies.
/// 8. Creating new types at the runtime.
/// System.Reflection.Emit namespace is used for that.
/// 9. And many more. 
/// 
/// Downside of this reflection:
/// Do not use it alot because it is hard to maintain and understand.
/// It is prone to errors.
/// It has a big impact on the performace.
/// For e.g. teacher had one task to improve the performance.
/// She saw that it uses a reflection alot, mostly to load some types and attributes
/// from DLLs at runtime.
/// It turned out that the results of those loads can be catched, and only this 
/// improvement made the process work twice as fast before.
/// If there is a way to implement the same logic without this then use that 
/// logic.
///